// This file is automatically generated. Do not edit it directly.
import { createClient } from '@supabase/supabase-js';
import type { Database } from './types';

const supabaseUrl = import.meta.env.VITE_SUPABASE_URL;
const supabaseKey = import.meta.env.VITE_SUPABASE_ANON_KEY;

if (!supabaseUrl || !supabaseKey) {
  console.error('Missing Supabase environment variables. Please check your .env file.');
}

// Import the supabase client like this:
// import { supabase } from "@/integrations/supabase/client";

// Connection state tracking
let connectionState = {
  lastChecked: 0,
  isAvailable: false,
  checkInProgress: false,
  connectionErrors: 0,
  maxConnectionErrors: 5,
  reconnectTimeout: null as NodeJS.Timeout | null,
};

// Custom fetch with timeout
const fetchWithTimeout = (url: RequestInfo | URL, options?: RequestInit, timeout = 60000) => {
  return new Promise<Response>((resolve, reject) => {
    // Create abort controller for timeout
    const controller = new AbortController();
    const timeoutId = setTimeout(() => controller.abort(), timeout);

    // Add signal to options
    const fetchOptions = {
      ...options,
      signal: controller.signal
    };

    fetch(url, fetchOptions)
      .then(response => {
        clearTimeout(timeoutId);
        resolve(response);
      })
      .catch(error => {
        clearTimeout(timeoutId);
        if (error.name === 'AbortError') {
          reject(new Error('Request timed out. Please check your connection and try again.'));
        } else {
          reject(error);
        }
      });
  });
};

export const supabase = createClient<Database>(supabaseUrl || '', supabaseKey || '', {
  auth: {
    persistSession: true,
    autoRefreshToken: true,
    detectSessionInUrl: true
  },
  global: {
    fetch: (url: RequestInfo | URL, options?: RequestInit) => {
      return fetchWithTimeout(url, options)
        .catch(err => {
          console.error('Supabase fetch error:', err);
          // Track connection errors
          connectionState.connectionErrors++;

          // If we've had too many errors, mark connection as unavailable
          if (connectionState.connectionErrors >= connectionState.maxConnectionErrors) {
            connectionState.isAvailable = false;
            scheduleReconnect();
          }

          throw new Error('Network error when connecting to Supabase. Please check your connection and try again.');
        });
    }
  },
  realtime: {
    params: {
      eventsPerSecond: 10
    }
  }
});

// Schedule a reconnection attempt
const scheduleReconnect = () => {
  if (connectionState.reconnectTimeout) {
    clearTimeout(connectionState.reconnectTimeout);
  }

  connectionState.reconnectTimeout = setTimeout(() => {
    checkSupabaseConnection(true)
      .then(available => {
        if (available) {
          console.log('Supabase connection restored');
          connectionState.connectionErrors = 0;
        } else {
          console.warn('Supabase reconnection failed, will retry later');
          scheduleReconnect();
        }
      })
      .catch(() => {
        console.warn('Supabase reconnection check failed, will retry later');
        scheduleReconnect();
      });
  }, 30000); // Try to reconnect after 30 seconds
};

// Function to check if Supabase connection is working
export const checkSupabaseConnection = async (force = false): Promise<boolean> => {
  // Don't check too frequently unless forced
  const now = Date.now();
  if (!force &&
    connectionState.lastChecked > 0 &&
    now - connectionState.lastChecked < 60000 && // 1 minute cache
    !connectionState.checkInProgress) {
    return connectionState.isAvailable;
  }

  // Prevent multiple simultaneous checks
  if (connectionState.checkInProgress) {
    // Wait for the current check to complete
    return new Promise((resolve) => {
      const checkInterval = setInterval(() => {
        if (!connectionState.checkInProgress) {
          clearInterval(checkInterval);
          resolve(connectionState.isAvailable);
        }
      }, 100);
    });
  }

  connectionState.checkInProgress = true;

  try {
    // Try a simple query to check connection
    const { error } = await supabase.from('site_content').select('id').limit(1);

    // Update connection state
    connectionState.lastChecked = now;
    connectionState.isAvailable = !error || error.code !== 'PGRST12';

    if (connectionState.isAvailable) {
      connectionState.connectionErrors = 0;
    }

    return connectionState.isAvailable;
  } catch (error) {
    console.error('Supabase connection error:', error);
    connectionState.lastChecked = now;
    connectionState.isAvailable = false;
    return false;
  } finally {
    connectionState.checkInProgress = false;
  }
};

// Function to handle Supabase errors consistently
export const handleSupabaseError = (error: any): string => {
  console.error('Supabase error:', error);

  if (typeof error === 'string') {
    return error;
  }

  if (error?.message) {
    return error.message;
  }

  if (error?.error_description) {
    return error.error_description;
  }

  return 'An unknown error occurred. Please try again.';
};

// Retry mechanism for Supabase operations
export const retryOperation = async <T>(
  operation: () => Promise<T>,
  maxRetries: number = 3,
  delay: number = 1000,
  onRetry?: (attempt: number, error: any) => void
): Promise<T> => {
  let lastError: any;

  for (let attempt = 0; attempt < maxRetries; attempt++) {
    try {
      // Check connection before operation
      if (attempt > 0) {
        const isConnected = await checkSupabaseConnection();
        if (!isConnected) {
          throw new Error("Cannot connect to database. Please check your connection and try again.");
        }
      }

      return await operation();
    } catch (error) {
      lastError = error;
      console.error(`Operation failed (attempt ${attempt + 1}/${maxRetries}):`, error);

      // Call onRetry callback if provided
      if (onRetry) {
        onRetry(attempt + 1, error);
      }

      if (attempt < maxRetries - 1) {
        // Wait before retrying with exponential backoff
        await new Promise(resolve => setTimeout(resolve, delay * Math.pow(2, attempt)));
      }
    }
  }

  throw lastError;
};

// Wrap Supabase operations with retry logic
export const safeQuery = async <T>(
  queryFn: () => Promise<T>,
  errorMessage = 'Database operation failed'
): Promise<T> => {
  try {
    // First check connection
    const isConnected = await checkSupabaseConnection();
    if (!isConnected) {
      throw new Error("Cannot connect to database. Please check your connection and try again.");
    }

    return await retryOperation(queryFn);
  } catch (error) {
    console.error(errorMessage, error);
    throw new Error(handleSupabaseError(error));
  }
};

// Initialize connection check
checkSupabaseConnection().then(available => {
  if (!available) {
    console.warn('Supabase connection is not available. Some features may not work properly.');
    scheduleReconnect();
  }
}).catch(err => {
  console.error('Failed to check Supabase connection:', err);
  scheduleReconnect();
});
